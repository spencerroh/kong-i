<!DOCTYPE html>
<html lang="ko">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>kong-i :: cat's favorite site ever!!</title>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  html, body { overflow: hidden; background: #000; }
  canvas { display: block; position: fixed; top: 0; left: 0; z-index: 1; }
  #bgFrame {
    position: fixed;
    top: 0; left: 0;
    width: 100%; height: 100%;
    border: none;
    z-index: 0;
    display: none;
  }

  /* Options Overlay */
  #overlay {
    display: none;
    position: fixed;
    top: 0; left: 0; right: 0; bottom: 0;
    background: rgba(0,0,0,0.4);
    z-index: 99;
  }
  /* Options Panel */
  #options {
    display: none;
    position: fixed;
    top: 50%; left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(20, 20, 20, 0.95);
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 16px;
    padding: 32px 40px;
    color: #eee;
    font-family: 'Segoe UI', sans-serif;
    z-index: 100;
    min-width: 560px;
    max-height: 80vh;
    overflow-y: auto;
    backdrop-filter: blur(12px);
    box-shadow: 0 20px 60px rgba(0,0,0,0.6);
  }
  .opt-columns {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 0 32px;
  }
  .opt-full {
    grid-column: 1 / -1;
  }
  #options.light-panel {
    background: rgba(245, 245, 245, 0.95);
    border-color: rgba(0,0,0,0.12);
    color: #222;
    box-shadow: 0 20px 60px rgba(0,0,0,0.15);
  }
  #options h2 {
    margin-bottom: 24px;
    font-size: 20px;
    font-weight: 600;
    letter-spacing: -0.3px;
  }
  .opt-group {
    display: block;
    margin-bottom: 20px;
  }
  .opt-group label {
    display: block;
    font-size: 12px;
    text-transform: uppercase;
    letter-spacing: 1px;
    opacity: 0.5;
    margin-bottom: 10px;
  }
  .opt-row {
    display: flex;
    gap: 8px;
  }
  .opt-btn {
    flex: 1;
    padding: 10px 0;
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 8px;
    background: rgba(255,255,255,0.05);
    color: #ccc;
    font-size: 13px;
    cursor: pointer;
    transition: all 0.15s;
    font-family: inherit;
  }
  .light-panel .opt-btn {
    border-color: rgba(0,0,0,0.12);
    background: rgba(0,0,0,0.04);
    color: #555;
  }
  .opt-btn:hover {
    background: rgba(255,255,255,0.12);
  }
  .light-panel .opt-btn:hover {
    background: rgba(0,0,0,0.08);
  }
  .opt-btn.active {
    background: rgba(100,140,255,0.25);
    border-color: #6a9fff;
    color: #fff;
  }
  .light-panel .opt-btn.active {
    background: rgba(60,100,220,0.15);
    border-color: #4a7ae0;
    color: #222;
  }
  .hint {
    margin-top: 24px;
    text-align: center;
    font-size: 11px;
    opacity: 0.3;
  }
  /* Color preview dots */
  .color-dots {
    display: flex;
    gap: 4px;
    justify-content: center;
    margin-top: 6px;
  }
  .color-dot {
    width: 8px; height: 8px;
    border-radius: 50%;
    border: 1px solid rgba(128,128,128,0.3);
  }
  /* URL input */
  .opt-input {
    width: 100%;
    padding: 8px 12px;
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 8px;
    background: rgba(255,255,255,0.05);
    color: #ccc;
    font-size: 13px;
    font-family: inherit;
    outline: none;
    transition: border-color 0.15s;
  }
  .opt-input:focus {
    border-color: #6a9fff;
  }
  .opt-input::placeholder {
    opacity: 0.4;
  }
  .light-panel .opt-input {
    border-color: rgba(0,0,0,0.12);
    background: rgba(0,0,0,0.04);
    color: #333;
  }
  .light-panel .opt-input:focus {
    border-color: #4a7ae0;
  }
  .opt-input-row {
    display: flex;
    gap: 8px;
  }
  .opt-input-btn {
    padding: 8px 14px;
    border: 1px solid rgba(255,255,255,0.15);
    border-radius: 8px;
    background: rgba(100,140,255,0.25);
    color: #fff;
    font-size: 12px;
    cursor: pointer;
    font-family: inherit;
    white-space: nowrap;
    transition: all 0.15s;
  }
  .opt-input-btn:hover {
    background: rgba(100,140,255,0.4);
  }
  .light-panel .opt-input-btn {
    background: rgba(60,100,220,0.15);
    border-color: rgba(0,0,0,0.12);
    color: #333;
  }
  /* Slider */
  .opt-slider {
    -webkit-appearance: none;
    appearance: none;
    display: block;
    width: 100%;
    height: 6px;
    border-radius: 3px;
    background: rgba(255,255,255,0.15);
    outline: none;
    cursor: pointer;
  }
  .opt-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 18px; height: 18px;
    border-radius: 50%;
    background: #6a9fff;
    border: 2px solid #fff;
    cursor: pointer;
  }
  .opt-slider::-moz-range-thumb {
    width: 18px; height: 18px;
    border-radius: 50%;
    background: #6a9fff;
    border: 2px solid #fff;
    cursor: pointer;
  }
  .light-panel .opt-slider {
    background: rgba(0,0,0,0.12);
  }
  .light-panel .opt-slider::-webkit-slider-thumb {
    background: #4a7ae0;
    border-color: #333;
  }
  .light-panel .opt-slider::-moz-range-thumb {
    background: #4a7ae0;
    border-color: #333;
  }
  .opt-preset-url {
    font-size: 11px;
    opacity: 0.4;
    margin-top: 6px;
    cursor: pointer;
    transition: opacity 0.15s;
  }
  .opt-preset-url:hover {
    opacity: 0.8;
    text-decoration: underline;
  }
  .opt-slider-val {
    text-align: center;
    font-size: 13px;
    margin-top: 6px;
    opacity: 0.6;
  }
  #hint-dblclick {
    position: fixed;
    bottom: 14px;
    right: 18px;
    font-family: 'Segoe UI', sans-serif;
    font-size: 12px;
    color: #fff;
    opacity: 0.5;
    z-index: 2;
    pointer-events: none;
    user-select: none;
    letter-spacing: 0.3px;
  }
  #fullscreen-btn {
    position: fixed;
    top: 14px;
    right: 18px;
    width: 28px;
    height: 28px;
    background: none;
    border: 1px solid rgba(255,255,255,0.2);
    border-radius: 6px;
    color: rgba(255,255,255,0.3);
    font-size: 14px;
    cursor: pointer;
    z-index: 2;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: opacity 0.15s;
    padding: 0;
  }
  #fullscreen-btn:hover {
    opacity: 0.7;
  }
  #brand {
    position: fixed;
    top: 14px;
    left: 18px;
    font-family: 'Segoe UI', sans-serif;
    font-size: 18px;
    letter-spacing: 0.5px;
    color: #fff;
    opacity: 0.22;
    z-index: 2;
    pointer-events: none;
    user-select: none;
  }
  #footer-email {
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Segoe UI', sans-serif;
    font-size: 9px;
    color: #fff;
    opacity: 0.1;
    z-index: 2;
    pointer-events: none;
    user-select: none;
    letter-spacing: 0.3px;
  }
</style>
</head>
<body>
<iframe id="bgFrame" scrolling="no"></iframe>
<canvas id="c"></canvas>
<div id="brand">kong-i</div>
<div id="footer-email">spencer.roh@gmail.com</div>
<div id="hint-dblclick">더블클릭: 설정</div>
<button id="fullscreen-btn" title="전체화면">⛶</button>

<div id="overlay"></div>
<div id="options">
  <h2>설정</h2>

  <div class="opt-columns">
    <div class="opt-group">
      <label>모드</label>
      <div class="opt-row">
        <button class="opt-btn" data-mode="dark">다크</button>
        <button class="opt-btn active" data-mode="light">라이트</button>
      </div>
    </div>

    <div class="opt-group">
      <label>크기</label>
      <div class="opt-row">
        <button class="opt-btn active" data-size="small">소</button>
        <button class="opt-btn" data-size="medium">중</button>
        <button class="opt-btn" data-size="large">대</button>
      </div>
    </div>

    <div class="opt-group opt-full">
      <label>색상</label>
      <div class="opt-row">
        <button class="opt-btn" data-color="rainbow">
          무지개
          <div class="color-dots">
            <span class="color-dot" style="background:#ff0000"></span>
            <span class="color-dot" style="background:#ff8800"></span>
            <span class="color-dot" style="background:#ffff00"></span>
            <span class="color-dot" style="background:#00cc00"></span>
            <span class="color-dot" style="background:#0066ff"></span>
            <span class="color-dot" style="background:#9900ff"></span>
          </div>
        </button>
        <button class="opt-btn active" data-color="inverted">
          반전
          <div class="color-dots">
            <span class="color-dot" style="background:#ffffff"></span>
            <span class="color-dot" style="background:#000000"></span>
          </div>
        </button>
        <button class="opt-btn" data-color="cool">
          쿨톤
          <div class="color-dots">
            <span class="color-dot" style="background:#0055ff"></span>
            <span class="color-dot" style="background:#ffe600"></span>
            <span class="color-dot" style="background:#00ff55"></span>
          </div>
        </button>
      </div>
    </div>

    <div class="opt-group opt-full">
      <label>모양</label>
      <div class="opt-row">
        <button class="opt-btn active" data-shape="circle">원</button>
        <button class="opt-btn" data-shape="cursor">커서</button>
        <button class="opt-btn" data-shape="mouse">쥐</button>
        <button class="opt-btn" data-shape="butterfly">나비</button>
        <button class="opt-btn" data-shape="dragonfly">잠자리</button>
      </div>
    </div>

    <div class="opt-group">
      <label>속도</label>
      <div class="opt-row">
        <button class="opt-btn" data-speed="slow">느림</button>
        <button class="opt-btn active" data-speed="normal">보통</button>
        <button class="opt-btn" data-speed="fast">빠름</button>
        <button class="opt-btn" data-speed="vfast">매우 빠름</button>
      </div>
    </div>

    <div class="opt-group">
      <label>발광</label>
      <div class="opt-row">
        <button class="opt-btn active" data-glow="on">켜기</button>
        <button class="opt-btn" data-glow="off">끄기</button>
      </div>
    </div>

    <div class="opt-group">
      <label>잔상</label>
      <div class="opt-row">
        <button class="opt-btn active" data-trail="on">켜기</button>
        <button class="opt-btn" data-trail="off">끄기</button>
      </div>
    </div>

    <div class="opt-group">
      <label>흔들림</label>
      <div class="opt-row">
        <button class="opt-btn" data-drift="off">없음</button>
        <button class="opt-btn active" data-drift="low">약</button>
        <button class="opt-btn" data-drift="medium">중</button>
        <button class="opt-btn" data-drift="high">강</button>
      </div>
    </div>

    <div class="opt-group">
      <label>장애물</label>
      <div class="opt-row">
        <button class="opt-btn" data-obstacles="off">없음</button>
        <button class="opt-btn" data-obstacles="low">적음</button>
        <button class="opt-btn active" data-obstacles="normal">보통</button>
        <button class="opt-btn" data-obstacles="high">많음</button>
      </div>
    </div>

    <div class="opt-group">
      <label>멈춤</label>
      <div class="opt-row">
        <button class="opt-btn" data-pause="off">없음</button>
        <button class="opt-btn active" data-pause="bounce">충돌시</button>
        <button class="opt-btn" data-pause="3s">3초</button>
        <button class="opt-btn" data-pause="5s">5초</button>
      </div>
    </div>

    <div class="opt-group" id="pauseDurGroup" style="display:none">
      <label>멈춤 시간</label>
      <div class="opt-row">
        <button class="opt-btn active" data-pausedur="1">1초</button>
        <button class="opt-btn" data-pausedur="2">2초</button>
        <button class="opt-btn" data-pausedur="3">3초</button>
      </div>
    </div>

    <div class="opt-group opt-full">
      <label>배경 URL</label>
      <div class="opt-input-row">
        <input class="opt-input" id="bgUrlInput" type="text" placeholder="https://example.com">
        <button class="opt-input-btn" id="bgUrlApply">적용</button>
        <button class="opt-input-btn" id="bgUrlClear">지우기</button>
      </div>
      <div class="opt-preset-url" id="presetUrl">https://www.wikipedia.org/</div>
    </div>

    <div class="opt-group opt-full" id="bgOpacityGroup" style="display:none">
      <label>배경 투명도</label>
      <div style="max-width:50%">
        <input type="range" class="opt-slider" id="bgOpacitySlider" min="0" max="100" value="50">
        <div class="opt-slider-val"><span id="bgOpacityVal">50</span>%</div>
      </div>
    </div>
  </div>

  <div class="hint">O키를 눌러 닫기</div>
</div>

<script>
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d');
const optPanel = document.getElementById('options');
const overlay = document.getElementById('overlay');
const bgFrame = document.getElementById('bgFrame');
let optionsOpen = false;

function resize() {
  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;
}
resize();
window.addEventListener('resize', resize);

// --- Settings ---
const sizeMap = { small: 8, medium: 16, large: 24 };
const speedMap = { slow: 2.34, normal: 4.66, fast: 7.0, vfast: 14.0 };
const driftMap = { off: 0, low: 0.06, medium: 0.15, high: 0.35 };
const obsMap = { off: 0, low: 5, normal: 10, high: 15 };
const defaults = { mode:'light', colorTheme:'inverted', size:'small', shape:'circle', speed:'normal', drift:'low', glow:'on', trail:'on', pause:'bounce', pausedur:'1', obstacles:'normal', bgUrl:'', bgopacity:50 };

function loadSettings() {
  try {
    const saved = JSON.parse(localStorage.getItem('bp-settings'));
    if (saved) return { ...defaults, ...saved };
  } catch(e) {}
  return { ...defaults };
}
function saveSettings() {
  localStorage.setItem('bp-settings', JSON.stringify(settings));
}

const settings = loadSettings();

const colorThemes = {
  rainbow: {
    dark:  ['#ff0000','#ff8800','#ffff00','#00cc00','#0066ff','#9900ff'],
    light: ['#cc0000','#dd6600','#cc9900','#008800','#0044cc','#7700cc']
  },
  inverted: {
    dark:  ['#ffffff'],
    light: ['#000000']
  },
  cool: {
    dark:  ['#0055ff','#00ccff','#ffe600','#00ff55','#0055ff'],
    light: ['#0033dd','#0099dd','#ddaa00','#00cc33','#0033dd']
  }
};

function getColors() {
  return colorThemes[settings.colorTheme][settings.mode];
}
function getBg() {
  return settings.mode === 'dark' ? '#000000' : '#ffffff';
}
function getBgFade() {
  const c = settings.mode === 'dark' ? '0,0,0' : '255,255,255';
  if (settings.bgUrl) {
    const opacity = settings.bgopacity / 100;
    return `rgba(${c},${opacity})`;
  }
  return `rgba(${c},1)`;
}

let colors = getColors();
let colorIndex = 0;
let lastColorChange = performance.now();
const COLOR_INTERVAL = 10000;

// --- Options UI ---
function openOptions() {
  optionsOpen = true;
  optPanel.style.display = 'block';
  overlay.style.display = 'block';
}
function closeOptions() {
  optionsOpen = false;
  optPanel.style.display = 'none';
  overlay.style.display = 'none';
}
function toggleOptions() {
  optionsOpen ? closeOptions() : openOptions();
}

overlay.addEventListener('click', closeOptions);

function updatePanelTheme() {
  const isLight = settings.mode === 'light';
  if (isLight) {
    optPanel.classList.add('light-panel');
  } else {
    optPanel.classList.remove('light-panel');
  }
  const overlayColor = isLight ? '#000' : '#fff';
  document.getElementById('brand').style.color = overlayColor;
  document.getElementById('footer-email').style.color = overlayColor;
  document.getElementById('hint-dblclick').style.color = overlayColor;
  document.getElementById('fullscreen-btn').style.color = isLight ? 'rgba(0,0,0,0.3)' : 'rgba(255,255,255,0.3)';
  document.getElementById('fullscreen-btn').style.borderColor = isLight ? 'rgba(0,0,0,0.2)' : 'rgba(255,255,255,0.2)';
}

// Bind option buttons
function bindOption(attr, fn) {
  document.querySelectorAll(`[data-${attr}]`).forEach(btn => {
    btn.addEventListener('click', () => {
      settings[attr === 'color' ? 'colorTheme' : attr] = btn.dataset[attr];
      document.querySelectorAll(`[data-${attr}]`).forEach(b => b.classList.remove('active'));
      btn.classList.add('active');
      if (fn) fn();
      saveSettings();
    });
  });
}

bindOption('mode', () => { colors = getColors(); colorIndex = 0; lastColorChange = performance.now(); updatePanelTheme(); });
bindOption('color', () => { colors = getColors(); colorIndex = 0; lastColorChange = performance.now(); });
bindOption('shape');
bindOption('size', () => { ball.radius = sizeMap[settings.size]; });
bindOption('speed');
bindOption('drift');
bindOption('glow');
bindOption('pause', () => {
  document.getElementById('pauseDurGroup').style.display = settings.pause === 'off' ? 'none' : 'block';
});
bindOption('pausedur');
document.getElementById('bgOpacitySlider').addEventListener('input', (e) => {
  settings.bgopacity = Number(e.target.value);
  document.getElementById('bgOpacityVal').textContent = settings.bgopacity;
  saveSettings();
});
bindOption('trail');
bindOption('obstacles', () => { generateObstacles(); });

// Restore UI from saved settings
function restoreUI() {
  document.querySelectorAll('[data-mode]').forEach(b => b.classList.toggle('active', b.dataset.mode === settings.mode));
  document.querySelectorAll('[data-color]').forEach(b => b.classList.toggle('active', b.dataset.color === settings.colorTheme));
  document.querySelectorAll('[data-shape]').forEach(b => b.classList.toggle('active', b.dataset.shape === settings.shape));
  document.querySelectorAll('[data-size]').forEach(b => b.classList.toggle('active', b.dataset.size === settings.size));
  document.querySelectorAll('[data-speed]').forEach(b => b.classList.toggle('active', b.dataset.speed === settings.speed));
  document.querySelectorAll('[data-drift]').forEach(b => b.classList.toggle('active', b.dataset.drift === settings.drift));
  document.querySelectorAll('[data-glow]').forEach(b => b.classList.toggle('active', b.dataset.glow === settings.glow));
  document.querySelectorAll('[data-pause]').forEach(b => b.classList.toggle('active', b.dataset.pause === settings.pause));
  document.querySelectorAll('[data-pausedur]').forEach(b => b.classList.toggle('active', b.dataset.pausedur === settings.pausedur));
  document.getElementById('pauseDurGroup').style.display = settings.pause === 'off' ? 'none' : 'block';
  document.querySelectorAll('[data-trail]').forEach(b => b.classList.toggle('active', b.dataset.trail === settings.trail));
  document.querySelectorAll('[data-obstacles]').forEach(b => b.classList.toggle('active', b.dataset.obstacles === settings.obstacles));
  document.getElementById('bgOpacitySlider').value = settings.bgopacity;
  document.getElementById('bgOpacityVal').textContent = settings.bgopacity;
  document.getElementById('bgUrlInput').value = settings.bgUrl;
  applyBgUrl();
  updatePanelTheme();
}

// --- Background URL ---
function applyBgUrl() {
  const hasBg = !!settings.bgUrl;
  if (hasBg) {
    bgFrame.src = settings.bgUrl;
    bgFrame.style.display = 'block';
  } else {
    bgFrame.src = '';
    bgFrame.style.display = 'none';
  }
  document.getElementById('bgOpacityGroup').style.display = hasBg ? 'block' : 'none';
}

document.getElementById('bgUrlApply').addEventListener('click', () => {
  settings.bgUrl = document.getElementById('bgUrlInput').value.trim();
  applyBgUrl();
  saveSettings();
});

document.getElementById('bgUrlClear').addEventListener('click', () => {
  settings.bgUrl = '';
  document.getElementById('bgUrlInput').value = '';
  applyBgUrl();
  saveSettings();
});

document.getElementById('bgUrlInput').addEventListener('keydown', (e) => {
  if (e.key === 'Enter') {
    settings.bgUrl = e.target.value.trim();
    applyBgUrl();
    saveSettings();
  }
  e.stopPropagation();
});

document.getElementById('presetUrl').addEventListener('click', () => {
  document.getElementById('bgUrlInput').value = 'https://www.wikipedia.org/';
});

restoreUI();

// Pointer
const ball = {
  x: canvas.width / 2,
  y: canvas.height / 2,
  vx: 0, vy: 0,
  radius: sizeMap[settings.size]
};

const initAngle = Math.random() * Math.PI * 2;
const initSpeed = speedMap[settings.speed];
ball.vx = initSpeed * Math.cos(initAngle);
ball.vy = initSpeed * Math.sin(initAngle);

// --- Perlin-like smooth noise ---
function createNoise() {
  const perm = [];
  for (let i = 0; i < 256; i++) perm[i] = i;
  for (let i = 255; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [perm[i], perm[j]] = [perm[j], perm[i]];
  }
  const p = [...perm, ...perm];
  function fade(t) { return t * t * t * (t * (t * 6 - 15) + 10); }
  function lerp(a, b, t) { return a + t * (b - a); }
  function grad(hash, x) { return (hash & 1) === 0 ? x : -x; }
  return function(x) {
    const xi = Math.floor(x) & 255;
    const xf = x - Math.floor(x);
    const u = fade(xf);
    return lerp(grad(p[xi], xf), grad(p[xi + 1], xf - 1), u);
  };
}
const noiseX = createNoise();
const noiseY = createNoise();
let noiseTime = Math.random() * 1000;

// --- Obstacles ---
const obstacles = [];

function createOneObstacle() {
  const w = 40 + Math.random() * 160;
  const h = 40 + Math.random() * 160;
  const x = Math.random() * (canvas.width - w);
  const y = Math.random() * (canvas.height - h);
  return { x, y, w, h };
}

function generateObstacles() {
  obstacles.length = 0;
  const count = obsMap[settings.obstacles] ?? 10;
  for (let i = 0; i < count; i++) obstacles.push(createOneObstacle());
}
generateObstacles();

// --- Sound ---
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

function playBounceSound() {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.frequency.value = 300 + Math.random() * 600;
  osc.type = 'sine';
  gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.12);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + 0.12);
}

function playWallSound() {
  const osc = audioCtx.createOscillator();
  const gain = audioCtx.createGain();
  osc.connect(gain);
  gain.connect(audioCtx.destination);
  osc.frequency.value = 150 + Math.random() * 100;
  osc.type = 'triangle';
  gain.gain.setValueAtTime(0.08, audioCtx.currentTime);
  gain.gain.exponentialRampToValueAtTime(0.001, audioCtx.currentTime + 0.08);
  osc.start(audioCtx.currentTime);
  osc.stop(audioCtx.currentTime + 0.08);
}

document.addEventListener('click', () => audioCtx.resume(), { once: true });
document.addEventListener('keydown', () => audioCtx.resume(), { once: true });

// --- Particles ---
const particles = [];

function spawnParticles(x, y, color) {
  const count = 6 + Math.floor(Math.random() * 6);
  for (let i = 0; i < count; i++) {
    const a = Math.random() * Math.PI * 2;
    const spd = 1 + Math.random() * 3;
    particles.push({
      x, y,
      vx: Math.cos(a) * spd,
      vy: Math.sin(a) * spd,
      life: 1,
      decay: 0.015 + Math.random() * 0.025,
      size: 2 + Math.random() * 3,
      color
    });
  }
}

// --- Firework particles ---
const fireworkColors = ['#ff0044','#ff8800','#ffee00','#00ff66','#0088ff','#aa00ff','#ff00aa','#ffffff'];

function spawnFirework(x, y) {
  const burstCount = 30 + Math.floor(Math.random() * 20);
  for (let i = 0; i < burstCount; i++) {
    const a = Math.random() * Math.PI * 2;
    const spd = 2 + Math.random() * 6;
    const color = fireworkColors[Math.floor(Math.random() * fireworkColors.length)];
    particles.push({
      x, y,
      vx: Math.cos(a) * spd,
      vy: Math.sin(a) * spd - Math.random() * 2,
      life: 1,
      decay: 0.004 + Math.random() * 0.0075,
      size: 2 + Math.random() * 4,
      color
    });
  }
}

function playFireworkSound() {
  const t = audioCtx.currentTime;

  // 팡 - 초기 폭발음
  const noise = audioCtx.createBufferSource();
  const buf = audioCtx.createBuffer(1, audioCtx.sampleRate * 0.15, audioCtx.sampleRate);
  const data = buf.getChannelData(0);
  for (let i = 0; i < data.length; i++) data[i] = (Math.random() * 2 - 1) * Math.exp(-i / (data.length * 0.15));
  noise.buffer = buf;
  const noiseGain = audioCtx.createGain();
  noiseGain.gain.setValueAtTime(0.15, t);
  noiseGain.gain.exponentialRampToValueAtTime(0.001, t + 0.15);
  noise.connect(noiseGain);
  noiseGain.connect(audioCtx.destination);
  noise.start(t);

  // 반짝이는 고음들
  const freqs = [1200, 1600, 2000, 2400];
  freqs.forEach((f, i) => {
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    osc.frequency.value = f + Math.random() * 400;
    osc.type = 'sine';
    const delay = 0.03 + i * 0.04;
    gain.gain.setValueAtTime(0, t);
    gain.gain.linearRampToValueAtTime(0.06, t + delay);
    gain.gain.exponentialRampToValueAtTime(0.001, t + delay + 0.2);
    osc.start(t + delay);
    osc.stop(t + delay + 0.2);
  });

  // 낮은 울림
  const bass = audioCtx.createOscillator();
  const bassGain = audioCtx.createGain();
  bass.connect(bassGain);
  bassGain.connect(audioCtx.destination);
  bass.frequency.value = 80 + Math.random() * 60;
  bass.type = 'triangle';
  bassGain.gain.setValueAtTime(0.1, t);
  bassGain.gain.exponentialRampToValueAtTime(0.001, t + 0.25);
  bass.start(t);
  bass.stop(t + 0.25);
}

canvas.addEventListener('click', (e) => {
  if (optionsOpen) return;
  spawnFirework(e.clientX, e.clientY);
  playFireworkSound();
});

// --- Collision ---
function collideBallRect(ball, rect) {
  const closestX = Math.max(rect.x, Math.min(ball.x, rect.x + rect.w));
  const closestY = Math.max(rect.y, Math.min(ball.y, rect.y + rect.h));
  const dx = ball.x - closestX;
  const dy = ball.y - closestY;
  const dist = Math.sqrt(dx * dx + dy * dy);

  if (dist < ball.radius) {
    const overlapX = ball.radius - Math.abs(dx);
    const overlapY = ball.radius - Math.abs(dy);
    const insideX = ball.x >= rect.x && ball.x <= rect.x + rect.w;
    const insideY = ball.y >= rect.y && ball.y <= rect.y + rect.h;

    if (insideX && !insideY) {
      ball.vy = -ball.vy;
      ball.y += (dy >= 0 ? overlapY : -overlapY);
    } else if (!insideX && insideY) {
      ball.vx = -ball.vx;
      ball.x += (dx >= 0 ? overlapX : -overlapX);
    } else if (!insideX && !insideY) {
      if (overlapX < overlapY) {
        ball.vx = -ball.vx;
        ball.x += (dx >= 0 ? overlapX : -overlapX);
      } else {
        ball.vy = -ball.vy;
        ball.y += (dy >= 0 ? overlapY : -overlapY);
      }
    } else {
      const toLeft = ball.x - rect.x;
      const toRight = rect.x + rect.w - ball.x;
      const toTop = ball.y - rect.y;
      const toBottom = rect.y + rect.h - ball.y;
      const m = Math.min(toLeft, toRight, toTop, toBottom);
      if (m === toLeft)       { ball.vx = -Math.abs(ball.vx); ball.x = rect.x - ball.radius; }
      else if (m === toRight) { ball.vx =  Math.abs(ball.vx); ball.x = rect.x + rect.w + ball.radius; }
      else if (m === toTop)   { ball.vy = -Math.abs(ball.vy); ball.y = rect.y - ball.radius; }
      else                    { ball.vy =  Math.abs(ball.vy); ball.y = rect.y + rect.h + ball.radius; }
    }

    ball.vx += (Math.random() - 0.5) * 1.2;
    ball.vy += (Math.random() - 0.5) * 1.2;
    return true;
  }
  return false;
}

// --- Animation timer ---
let animTime = 0;

// --- Shape drawing functions ---
function getAngle() {
  return Math.atan2(ball.vy, ball.vx);
}

function drawCircle(x, y, r, color) {
  ctx.beginPath();
  ctx.arc(x, y, r, 0, Math.PI * 2);
  ctx.fillStyle = color;
  ctx.fill();
}

function drawCursor(x, y, r, color) {
  ctx.save();
  ctx.translate(x, y);
  const s = r * 1.8;
  ctx.fillStyle = color;
  ctx.strokeStyle = settings.mode === 'dark' ? '#000' : '#fff';
  ctx.lineWidth = r * 0.12;
  ctx.lineJoin = 'round';

  // Standard mouse cursor pointing upper-left
  // Left edge: straight down (90°), Right edge: ~43° → bisector ≈ 66.5°
  ctx.beginPath();
  ctx.moveTo(0, 0);                    // tip
  ctx.lineTo(0, s * 1.0);             // left edge bottom
  ctx.lineTo(s * 0.16, s * 0.71);     // left kink
  ctx.lineTo(s * 0.27, s * 0.97);     // handle bottom-left
  ctx.lineTo(s * 0.44, s * 0.90);     // handle bottom-right
  ctx.lineTo(s * 0.33, s * 0.64);     // right kink
  ctx.lineTo(s * 0.70, s * 0.65);     // right wing
  ctx.closePath();
  ctx.fill();
  ctx.stroke();

  ctx.restore();
}

function drawMouse(x, y, r, color) {
  const a = getAngle();
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(a);
  const s = r / 8;
  ctx.fillStyle = color;

  // Body (oval)
  ctx.beginPath();
  ctx.ellipse(0, 0, r * 1.3, r * 0.85, 0, 0, Math.PI * 2);
  ctx.fill();

  // Head
  ctx.beginPath();
  ctx.arc(r * 1.1, 0, r * 0.6, 0, Math.PI * 2);
  ctx.fill();

  // Ears
  ctx.beginPath();
  ctx.arc(r * 1.4, -r * 0.7, r * 0.35, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(r * 1.4, r * 0.7, r * 0.35, 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  const eyeColor = settings.mode === 'dark' ? '#000' : '#fff';
  ctx.fillStyle = eyeColor;
  ctx.beginPath();
  ctx.arc(r * 1.35, -r * 0.2, r * 0.12, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(r * 1.35, r * 0.2, r * 0.12, 0, Math.PI * 2);
  ctx.fill();

  // Tail
  ctx.strokeStyle = color;
  ctx.lineWidth = s * 0.8;
  ctx.lineCap = 'round';
  ctx.beginPath();
  ctx.moveTo(-r * 1.3, 0);
  ctx.quadraticCurveTo(-r * 2, -r * 0.8, -r * 2.2, -r * 0.2);
  ctx.stroke();

  // Whiskers
  ctx.lineWidth = s * 0.4;
  ctx.strokeStyle = color;
  for (const dy of [-1, 1]) {
    ctx.beginPath();
    ctx.moveTo(r * 1.5, dy * r * 0.15);
    ctx.lineTo(r * 2.2, dy * r * 0.5);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(r * 1.5, dy * r * 0.05);
    ctx.lineTo(r * 2.3, dy * r * 0.15);
    ctx.stroke();
  }

  ctx.restore();
}

function drawButterfly(x, y, r, color) {
  const a = getAngle();
  const wingFlap = Math.sin(animTime * 8) * 0.4 + 0.6;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(a);
  ctx.fillStyle = color;

  // Upper wings (round, plump)
  for (const side of [-1, 1]) {
    ctx.save();
    ctx.scale(1, side * wingFlap);
    ctx.beginPath();
    ctx.moveTo(-r * 0.2, 0);
    ctx.bezierCurveTo(r * 0.0, -r * 2.2, r * 2.0, -r * 2.0, r * 0.8, -r * 0.2);
    ctx.bezierCurveTo(r * 0.5, -r * 0.1, r * 0.0, -r * 0.05, -r * 0.2, 0);
    ctx.fill();
    ctx.restore();
  }

  // Lower wings (round, plump)
  for (const side of [-1, 1]) {
    ctx.save();
    ctx.scale(1, side * wingFlap);
    ctx.beginPath();
    ctx.moveTo(-r * 0.1, 0);
    ctx.bezierCurveTo(-r * 0.3, -r * 1.8, -r * 2.0, -r * 1.5, -r * 1.0, -r * 0.15);
    ctx.bezierCurveTo(-r * 0.6, -r * 0.05, -r * 0.3, 0, -r * 0.1, 0);
    ctx.fill();
    ctx.restore();
  }

  // Body
  ctx.beginPath();
  ctx.ellipse(0, 0, r * 0.9, r * 0.22, 0, 0, Math.PI * 2);
  ctx.fill();

  // Antennae
  ctx.strokeStyle = color;
  ctx.lineWidth = r * 0.08;
  ctx.lineCap = 'round';
  for (const side of [-1, 1]) {
    ctx.beginPath();
    ctx.moveTo(r * 0.7, 0);
    ctx.quadraticCurveTo(r * 0.85, side * r * 0.35, r * 1.0, side * r * 0.45);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(r * 1.0, side * r * 0.45, r * 0.08, 0, Math.PI * 2);
    ctx.fillStyle = color;
    ctx.fill();
  }

  ctx.restore();
}

function drawDragonfly(x, y, r, color) {
  const a = getAngle();
  const wingFlap = Math.sin(animTime * 14) * 0.35 + 0.65;
  ctx.save();
  ctx.translate(x, y);
  ctx.rotate(a);
  ctx.fillStyle = color;

  // Tail (long abdomen)
  ctx.beginPath();
  ctx.ellipse(-r * 0.8, 0, r * 1.0, r * 0.15, 0, 0, Math.PI * 2);
  ctx.fill();

  // Thorax
  ctx.beginPath();
  ctx.arc(0, 0, r * 0.4, 0, Math.PI * 2);
  ctx.fill();

  // Head
  ctx.beginPath();
  ctx.arc(r * 0.6, 0, r * 0.3, 0, Math.PI * 2);
  ctx.fill();

  // Eyes
  const eyeColor = settings.mode === 'dark' ? '#000' : '#fff';
  ctx.fillStyle = eyeColor;
  ctx.beginPath();
  ctx.arc(r * 0.8, -r * 0.15, r * 0.12, 0, Math.PI * 2);
  ctx.fill();
  ctx.beginPath();
  ctx.arc(r * 0.8, r * 0.15, r * 0.12, 0, Math.PI * 2);
  ctx.fill();

  // Wings (4 wings, transparent)
  ctx.fillStyle = hexToRgba(color, 0.35);
  ctx.strokeStyle = color;
  ctx.lineWidth = r * 0.06;

  // Front wings
  for (const side of [-1, 1]) {
    ctx.save();
    ctx.scale(1, side * wingFlap);
    ctx.beginPath();
    ctx.moveTo(r * 0.1, 0);
    ctx.bezierCurveTo(r * 0.6, -r * 2, r * 1.8, -r * 1.2, r * 0.2, -r * 0.1);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  // Rear wings
  for (const side of [-1, 1]) {
    ctx.save();
    ctx.scale(1, side * wingFlap);
    ctx.beginPath();
    ctx.moveTo(-r * 0.2, 0);
    ctx.bezierCurveTo(-r * 0.1, -r * 1.6, -r * 1.4, -r * 1.1, -r * 0.3, -r * 0.1);
    ctx.fill();
    ctx.stroke();
    ctx.restore();
  }

  ctx.restore();
}

function drawShape(x, y, r, color) {
  switch (settings.shape) {
    case 'cursor':     drawCursor(x, y, r, color); break;
    case 'mouse':     drawMouse(x, y, r, color); break;
    case 'butterfly':  drawButterfly(x, y, r, color); break;
    case 'dragonfly':  drawDragonfly(x, y, r, color); break;
    default:           drawCircle(x, y, r, color); break;
  }
}

// --- Trail ---
const trail = [];
const TRAIL_LENGTH = 40;

// --- Speed management ---
function normalizeSpeed() {
  const spd = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
  const base = speedMap[settings.speed];
  const target = base + Math.sin(noiseTime * 0.3) * (base * 0.4);
  if (spd > 0.1) {
    const factor = target / spd;
    const blend = 0.05;
    ball.vx *= 1 + (factor - 1) * blend;
    ball.vy *= 1 + (factor - 1) * blend;
  }
}

// --- Pause state ---
let paused = false;
let pauseUntil = 0;
let lastIntervalPause = 0;
const pauseIntervalMap = { '3s': 3000, '5s': 5000 };

function triggerPause(now) {
  paused = true;
  pauseUntil = now + Number(settings.pausedur) * 1000;
}

function update(now, scale) {
  if (optionsOpen) return;

  // Handle pause timing
  if (paused) {
    if (now >= pauseUntil) {
      paused = false;
    } else {
      // Still update particles while paused
      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.x += p.vx * scale; p.y += p.vy * scale;
        p.vx *= Math.pow(0.97, scale); p.vy *= Math.pow(0.97, scale);
        p.life -= p.decay * scale;
        if (p.life <= 0) particles.splice(i, 1);
      }
      return;
    }
  }

  // Interval-based pause
  if (settings.pause === '3s' || settings.pause === '5s') {
    const interval = pauseIntervalMap[settings.pause];
    if (now - lastIntervalPause >= interval) {
      lastIntervalPause = now;
      triggerPause(now);
      return;
    }
  }

  if (now - lastColorChange >= COLOR_INTERVAL) {
    colorIndex = (colorIndex + 1) % colors.length;
    lastColorChange = now;
  }

  noiseTime += 0.012 * scale;
  const drift = driftMap[settings.drift];
  ball.vx += noiseX(noiseTime) * drift * scale;
  ball.vy += noiseY(noiseTime + 100) * drift * scale;
  normalizeSpeed();

  ball.x += ball.vx * scale;
  ball.y += ball.vy * scale;

  let hitWall = false;
  if (ball.x - ball.radius < 0)            { ball.x = ball.radius; ball.vx = Math.abs(ball.vx); hitWall = true; }
  if (ball.x + ball.radius > canvas.width)  { ball.x = canvas.width - ball.radius; ball.vx = -Math.abs(ball.vx); hitWall = true; }
  if (ball.y - ball.radius < 0)            { ball.y = ball.radius; ball.vy = Math.abs(ball.vy); hitWall = true; }
  if (ball.y + ball.radius > canvas.height) { ball.y = canvas.height - ball.radius; ball.vy = -Math.abs(ball.vy); hitWall = true; }
  if (hitWall) {
    playWallSound();
    spawnParticles(ball.x, ball.y, colors[colorIndex]);
    if (settings.pause === 'bounce') triggerPause(now);
  }

  for (let i = obstacles.length - 1; i >= 0; i--) {
    if (collideBallRect(ball, obstacles[i])) {
      playBounceSound();
      spawnParticles(ball.x, ball.y, colors[colorIndex]);
      obstacles.splice(i, 1);
      if (obstacles.length < (obsMap[settings.obstacles] ?? 10)) obstacles.push(createOneObstacle());
      if (settings.pause === 'bounce') triggerPause(now);
    }
  }

  for (let i = particles.length - 1; i >= 0; i--) {
    const p = particles[i];
    p.x += p.vx * scale;
    p.y += p.vy * scale;
    p.vy += 0.04 * scale;
    p.vx *= Math.pow(0.97, scale);
    p.vy *= Math.pow(0.97, scale);
    p.life -= p.decay * scale;
    if (p.life <= 0) particles.splice(i, 1);
  }

  trail.push({ x: ball.x, y: ball.y });
  if (trail.length > TRAIL_LENGTH) trail.shift();
}

function draw() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.fillStyle = getBgFade();
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  animTime += 0.016;
  const color = colors[colorIndex];

  for (const p of particles) {
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.size * p.life, 0, Math.PI * 2);
    ctx.fillStyle = hexToRgba(p.color, p.life * 0.8);
    ctx.fill();
  }

  // Trail - draw from trail array
  if (settings.trail === 'on' && trail.length > 1) {
    for (let i = 0; i < trail.length; i++) {
      const t = i / trail.length;
      const alpha = t * 0.5;
      const radius = t * ball.radius * 0.8;
      ctx.beginPath();
      ctx.arc(trail[i].x, trail[i].y, radius, 0, Math.PI * 2);
      ctx.fillStyle = hexToRgba(color, alpha);
      ctx.fill();
    }
  }

  if (settings.glow === 'on') {
    ctx.shadowColor = color;
    ctx.shadowBlur = 25;
  }
  drawShape(ball.x, ball.y, ball.radius, color);
  ctx.shadowBlur = 0;
}

function hexToRgba(hex, alpha) {
  const r = parseInt(hex.slice(1, 3), 16);
  const g = parseInt(hex.slice(3, 5), 16);
  const b = parseInt(hex.slice(5, 7), 16);
  return `rgba(${r},${g},${b},${alpha})`;
}

let lastFrameTime = 0;
const TARGET_FPS = 60;
const TARGET_DT = 1000 / TARGET_FPS;

function loop(now) {
  if (!lastFrameTime) lastFrameTime = now;
  let dt = now - lastFrameTime;
  lastFrameTime = now;

  // Cap delta to prevent huge jumps (e.g. after tab switch or context menu)
  if (dt > 100) dt = TARGET_DT;

  const scale = dt / TARGET_DT;
  update(now, scale);
  draw();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// --- Key handler ---
document.addEventListener('keydown', (e) => {
  if (e.key === 'o' || e.key === 'O' || e.key === 'ㅐ') {
    toggleOptions();
  }
});

canvas.addEventListener('dblclick', (e) => {
  e.preventDefault();
  toggleOptions();
});

window.addEventListener('resize', () => {
  resize();
  generateObstacles();
});

// --- Fullscreen ---
const fsBtn = document.getElementById('fullscreen-btn');
fsBtn.addEventListener('click', () => {
  if (!document.fullscreenElement) {
    document.documentElement.requestFullscreen();
  } else {
    document.exitFullscreen();
  }
});
document.addEventListener('fullscreenchange', () => {
  fsBtn.textContent = document.fullscreenElement ? '✕' : '⛶';
});

// --- Wake Lock (prevent screen saver) ---
let wakeLock = null;
async function requestWakeLock() {
  try {
    if ('wakeLock' in navigator) {
      wakeLock = await navigator.wakeLock.request('screen');
    }
  } catch(e) {}
}
requestWakeLock();
document.addEventListener('visibilitychange', () => {
  if (document.visibilityState === 'visible') requestWakeLock();
});
</script>
</body>
</html>
